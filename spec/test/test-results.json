[
  {
    "test_case": {
      "name": "simple_object_value_change",
      "description": "Basic object property value change",
      "category": "core",
      "content_a": "{\"a\":1}",
      "content_b": "{\"a\":2}",
      "expected_diff": "@ [\"a\"]\n- 1\n+ 2\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"a\"]\n- 1\n+ 2\n",
    "duration": "4.593047ms"
  },
  {
    "test_case": {
      "name": "nested_object_value_change",
      "description": "Change value in nested object",
      "category": "core",
      "content_a": "{\"a\":{\"b\":1}}",
      "content_b": "{\"a\":{\"b\":2}}",
      "expected_diff": "@ [\"a\",\"b\"]\n- 1\n+ 2\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"a\",\"b\"]\n- 1\n+ 2\n",
    "duration": "4.841036ms"
  },
  {
    "test_case": {
      "name": "array_element_change",
      "description": "Change array element with context",
      "category": "core",
      "content_a": "{\"foo\":[\"bar\",\"baz\"]}",
      "content_b": "{\"foo\":[\"bar\",\"boom\"]}",
      "expected_diff": "@ [\"foo\",1]\n  \"bar\"\n- \"baz\"\n+ \"boom\"\n]\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"foo\",1]\n  \"bar\"\n- \"baz\"\n+ \"boom\"\n]\n",
    "duration": "8.09791ms"
  },
  {
    "test_case": {
      "name": "string_value_change",
      "description": "Simple string property change",
      "category": "core",
      "content_a": "{\"a\":\"bar\"}",
      "content_b": "{\"a\":\"baz\"}",
      "expected_diff": "@ [\"a\"]\n- \"bar\"\n+ \"baz\"\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"a\"]\n- \"bar\"\n+ \"baz\"\n",
    "duration": "5.406566ms"
  },
  {
    "test_case": {
      "name": "object_to_null",
      "description": "Replace object with null",
      "category": "core",
      "content_a": "{\"a\":1}",
      "content_b": "null",
      "expected_diff": "@ []\n- {\"a\":1}\n+ null\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ []\n- {\"a\":1}\n+ null\n",
    "duration": "6.059565ms"
  },
  {
    "test_case": {
      "name": "null_to_object",
      "description": "Replace null with object",
      "category": "core",
      "content_a": "null",
      "content_b": "{\"a\":1}",
      "expected_diff": "@ []\n- null\n+ {\"a\":1}\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ []\n- null\n+ {\"a\":1}\n",
    "duration": "11.863504ms"
  },
  {
    "test_case": {
      "name": "object_to_array",
      "description": "Replace object with array",
      "category": "core",
      "content_a": "{\"a\":1}",
      "content_b": "[1]",
      "expected_diff": "@ []\n- {\"a\":1}\n+ [1]\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ []\n- {\"a\":1}\n+ [1]\n",
    "duration": "8.47912ms"
  },
  {
    "test_case": {
      "name": "array_to_object",
      "description": "Replace array with object",
      "category": "core",
      "content_a": "[1]",
      "content_b": "{\"a\":1}",
      "expected_diff": "@ []\n- [1]\n+ {\"a\":1}\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ []\n- [1]\n+ {\"a\":1}\n",
    "duration": "9.525373ms"
  },
  {
    "test_case": {
      "name": "boolean_to_number",
      "description": "Type change from boolean to number",
      "category": "core",
      "content_a": "true",
      "content_b": "1",
      "expected_diff": "@ []\n- true\n+ 1\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ []\n- true\n+ 1\n",
    "duration": "5.844674ms"
  },
  {
    "test_case": {
      "name": "string_to_boolean",
      "description": "Type change from string to boolean",
      "category": "core",
      "content_a": "\"true\"",
      "content_b": "true",
      "expected_diff": "@ []\n- \"true\"\n+ true\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ []\n- \"true\"\n+ true\n",
    "duration": "7.564398ms"
  },
  {
    "test_case": {
      "name": "identical_documents",
      "description": "No differences between identical documents",
      "category": "core",
      "content_a": "{\"a\":1,\"b\":2}",
      "content_b": "{\"a\":1,\"b\":2}",
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "5.255732ms"
  },
  {
    "test_case": {
      "name": "array_append",
      "description": "Add element to end of array",
      "category": "core",
      "content_a": "[1,2]",
      "content_b": "[1,2,3]",
      "expected_diff": "@ [2]\n  2\n+ 3\n]\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [2]\n  2\n+ 3\n]\n",
    "duration": "9.119456ms"
  },
  {
    "test_case": {
      "name": "array_prepend",
      "description": "Add element to beginning of array",
      "category": "core",
      "content_a": "[2,3]",
      "content_b": "[1,2,3]",
      "expected_diff": "@ [0]\n[\n+ 1\n  2\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [0]\n[\n+ 1\n  2\n",
    "duration": "4.721751ms"
  },
  {
    "test_case": {
      "name": "object_key_addition",
      "description": "Add new property to object",
      "category": "core",
      "content_a": "{\"a\":1}",
      "content_b": "{\"a\":1,\"b\":2}",
      "expected_diff": "@ [\"b\"]\n+ 2\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"b\"]\n+ 2\n",
    "duration": "6.010891ms"
  },
  {
    "test_case": {
      "name": "object_key_removal",
      "description": "Remove property from object",
      "category": "core",
      "content_a": "{\"a\":1,\"b\":2}",
      "content_b": "{\"a\":1}",
      "expected_diff": "@ [\"b\"]\n- 2\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"b\"]\n- 2\n",
    "duration": "7.565964ms"
  },
  {
    "test_case": {
      "name": "unicode_strings",
      "description": "Handle Unicode strings properly",
      "category": "core",
      "content_a": "{\"text\":\"こんにちは\"}",
      "content_b": "{\"text\":\"さようなら\"}",
      "expected_diff": "@ [\"text\"]\n- \"こんにちは\"\n+ \"さようなら\"\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"text\"]\n- \"こんにちは\"\n+ \"さようなら\"\n",
    "duration": "5.602344ms"
  },
  {
    "test_case": {
      "name": "empty_to_value",
      "description": "Add value from empty/void state",
      "category": "core",
      "content_b": "42",
      "expected_diff": "@ []\n+ 42\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ []\n+ 42\n",
    "duration": "7.50154ms"
  },
  {
    "test_case": {
      "name": "value_to_empty",
      "description": "Remove value to empty/void state",
      "category": "core",
      "content_a": "42",
      "expected_diff": "@ []\n- 42\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ []\n- 42\n",
    "duration": "4.871926ms"
  },
  {
    "test_case": {
      "name": "complex_array_context",
      "description": "Array changes with proper context preservation",
      "category": "core",
      "content_a": "[\"apple\",\"banana\",\"cherry\",\"date\"]",
      "content_b": "[\"apple\",\"blueberry\",\"cranberry\",\"date\"]",
      "expected_diff": "@ [1]\n  \"apple\"\n- \"banana\"\n- \"cherry\"\n+ \"blueberry\"\n+ \"cranberry\"\n  \"date\"\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [1]\n  \"apple\"\n- \"banana\"\n- \"cherry\"\n+ \"blueberry\"\n+ \"cranberry\"\n  \"date\"\n",
    "duration": "5.336876ms"
  },
  {
    "test_case": {
      "name": "empty_objects",
      "description": "Diff between empty objects",
      "category": "edge_cases",
      "content_a": "{}",
      "content_b": "{}",
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "4.430756ms"
  },
  {
    "test_case": {
      "name": "empty_arrays",
      "description": "Diff between empty arrays",
      "category": "edge_cases",
      "content_a": "[]",
      "content_b": "[]",
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "4.504895ms"
  },
  {
    "test_case": {
      "name": "null_values",
      "description": "Diff with null values",
      "category": "edge_cases",
      "content_a": "{\"a\": null}",
      "content_b": "{\"a\": null}",
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "5.102077ms"
  },
  {
    "test_case": {
      "name": "null_to_value",
      "description": "Change null to actual value",
      "category": "edge_cases",
      "content_a": "{\"a\": null}",
      "content_b": "{\"a\": \"value\"}",
      "expected_diff": "@ [\"a\"]\n- null\n+ \"value\"\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"a\"]\n- null\n+ \"value\"\n",
    "duration": "6.815455ms"
  },
  {
    "test_case": {
      "name": "value_to_null",
      "description": "Change value to null",
      "category": "edge_cases",
      "content_a": "{\"a\": \"value\"}",
      "content_b": "{\"a\": null}",
      "expected_diff": "@ [\"a\"]\n- \"value\"\n+ null\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"a\"]\n- \"value\"\n+ null\n",
    "duration": "7.069139ms"
  },
  {
    "test_case": {
      "name": "deeply_nested",
      "description": "Deeply nested structure changes",
      "category": "edge_cases",
      "content_a": "{\"a\":{\"b\":{\"c\":{\"d\":{\"e\":\"old\"}}}}}",
      "content_b": "{\"a\":{\"b\":{\"c\":{\"d\":{\"e\":\"new\"}}}}}",
      "expected_diff": "@ [\"a\",\"b\",\"c\",\"d\",\"e\"]\n- \"old\"\n+ \"new\"\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"a\",\"b\",\"c\",\"d\",\"e\"]\n- \"old\"\n+ \"new\"\n",
    "duration": "10.202406ms"
  },
  {
    "test_case": {
      "name": "special_characters_keys",
      "description": "Object keys with special characters",
      "category": "edge_cases",
      "content_a": "{\"key with spaces\": 1, \"key/with/slashes\": 2}",
      "content_b": "{\"key with spaces\": 2, \"key/with/slashes\": 2}",
      "expected_diff": "@ [\"key with spaces\"]\n- 1\n+ 2\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"key with spaces\"]\n- 1\n+ 2\n",
    "duration": "4.601568ms"
  },
  {
    "test_case": {
      "name": "unicode_keys",
      "description": "Unicode characters in object keys",
      "category": "edge_cases",
      "content_a": "{\"키\": \"값1\"}",
      "content_b": "{\"키\": \"값2\"}",
      "expected_diff": "@ [\"키\"]\n- \"값1\"\n+ \"값2\"\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"키\"]\n- \"값1\"\n+ \"값2\"\n",
    "duration": "4.989982ms"
  },
  {
    "test_case": {
      "name": "large_numbers",
      "description": "Very large number values",
      "category": "edge_cases",
      "content_a": "{\"big\": 9007199254740991}",
      "content_b": "{\"big\": 9007199254740992}",
      "expected_diff": "@ [\"big\"]\n- 9007199254740991\n+ 9007199254740992\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"big\"]\n- 9007199254740991\n+ 9007199254740992\n",
    "duration": "8.860227ms"
  },
  {
    "test_case": {
      "name": "scientific_notation",
      "description": "Numbers in scientific notation",
      "category": "edge_cases",
      "content_a": "{\"sci\": 1e10}",
      "content_b": "{\"sci\": 2e10}",
      "expected_diff": "@ [\"sci\"]\n- 10000000000\n+ 20000000000\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"sci\"]\n- 10000000000\n+ 20000000000\n",
    "duration": "5.385769ms"
  },
  {
    "test_case": {
      "name": "floating_point_precision",
      "description": "Floating point precision edge case",
      "category": "edge_cases",
      "content_a": "{\"float\": 0.1}",
      "content_b": "{\"float\": 0.10000000000000001}",
      "expected_diff": "@ [\"float\"]\n- 0.1\n+ 0.10000000000000001\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": false,
    "actual_exit": 0,
    "error": "exit code mismatch: expected 1, got 0",
    "duration": "5.511812ms"
  },
  {
    "test_case": {
      "name": "zero_variants",
      "description": "Different representations of zero",
      "category": "edge_cases",
      "content_a": "{\"zero\": 0}",
      "content_b": "{\"zero\": 0.0}",
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "10.90204ms"
  },
  {
    "test_case": {
      "name": "negative_zero",
      "description": "Negative zero handling",
      "category": "edge_cases",
      "content_a": "{\"nz\": 0}",
      "content_b": "{\"nz\": -0}",
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "5.922424ms"
  },
  {
    "test_case": {
      "name": "escaped_strings",
      "description": "Strings with escape sequences",
      "category": "edge_cases",
      "content_a": "{\"escaped\": \"line1\\nline2\\ttab\"}",
      "content_b": "{\"escaped\": \"line1\\nline2\\tmodified\"}",
      "expected_diff": "@ [\"escaped\"]\n- \"line1\\nline2\\ttab\"\n+ \"line1\\nline2\\tmodified\"\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"escaped\"]\n- \"line1\\nline2\\ttab\"\n+ \"line1\\nline2\\tmodified\"\n",
    "duration": "4.539186ms"
  },
  {
    "test_case": {
      "name": "unicode_escape",
      "description": "Unicode escape sequences",
      "category": "edge_cases",
      "content_a": "{\"unicode\": \"\\u0048\\u0065\\u006c\\u006c\\u006f\"}",
      "content_b": "{\"unicode\": \"Hello\"}",
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "7.888306ms"
  },
  {
    "test_case": {
      "name": "mixed_array_types",
      "description": "Array with mixed value types",
      "category": "edge_cases",
      "content_a": "[1, \"string\", true, null, {\"obj\": \"val\"}]",
      "content_b": "[1, \"string\", false, null, {\"obj\": \"val\"}]",
      "expected_diff": "@ [2]\n[\n  1\n  \"string\"\n- true\n+ false\n  null\n  {\"obj\":\"val\"}\n]\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "@ [2]\n  \"string\"\n- true\n+ false\n  null\n",
    "error": "output mismatch:\nExpected:\n@ [2]\n[\n  1\n  \"string\"\n- true\n+ false\n  null\n  {\"obj\":\"val\"}\n]\n\nActual:\n@ [2]\n  \"string\"\n- true\n+ false\n  null\n",
    "duration": "6.087665ms"
  },
  {
    "test_case": {
      "name": "array_index_beyond_bounds",
      "description": "Array operations beyond current bounds",
      "category": "edge_cases",
      "content_a": "[1, 2]",
      "content_b": "[1, 2, 3, 4, 5]",
      "expected_diff": "@ [2]\n[\n  1\n  2\n+ 3\n+ 4\n+ 5\n]\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "@ [2]\n  2\n+ 3\n+ 4\n+ 5\n]\n",
    "error": "output mismatch:\nExpected:\n@ [2]\n[\n  1\n  2\n+ 3\n+ 4\n+ 5\n]\n\nActual:\n@ [2]\n  2\n+ 3\n+ 4\n+ 5\n]\n",
    "duration": "4.710954ms"
  },
  {
    "test_case": {
      "name": "empty_string_key",
      "description": "Object with empty string as key",
      "category": "edge_cases",
      "content_a": "{\"\": \"empty_key\"}",
      "content_b": "{\"\": \"modified_empty_key\"}",
      "expected_diff": "@ [\"\"]\n- \"empty_key\"\n+ \"modified_empty_key\"\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"\"]\n- \"empty_key\"\n+ \"modified_empty_key\"\n",
    "duration": "4.864878ms"
  },
  {
    "test_case": {
      "name": "single_element_array",
      "description": "Array with single element modification",
      "category": "edge_cases",
      "content_a": "[\"only\"]",
      "content_b": "[\"changed\"]",
      "expected_diff": "@ [0]\n[\n- \"only\"\n+ \"changed\"\n]\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [0]\n[\n- \"only\"\n+ \"changed\"\n]\n",
    "duration": "5.167998ms"
  },
  {
    "test_case": {
      "name": "array_to_empty",
      "description": "Array becomes empty",
      "category": "edge_cases",
      "content_a": "[1, 2, 3]",
      "content_b": "[]",
      "expected_diff": "@ [0]\n[\n- 1\n- 2\n- 3\n]\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [0]\n[\n- 1\n- 2\n- 3\n]\n",
    "duration": "4.607586ms"
  },
  {
    "test_case": {
      "name": "empty_to_array",
      "description": "Empty array gets elements",
      "category": "edge_cases",
      "content_a": "[]",
      "content_b": "[1, 2, 3]",
      "expected_diff": "@ [0]\n[\n+ 1\n+ 2\n+ 3\n]\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [0]\n[\n+ 1\n+ 2\n+ 3\n]\n",
    "duration": "4.965017ms"
  },
  {
    "test_case": {
      "name": "duplicate_object_keys_set",
      "description": "Objects with duplicate keys in set mode",
      "category": "edge_cases",
      "content_a": "[{\"id\": 1, \"name\": \"A\"}, {\"id\": 1, \"name\": \"B\"}]",
      "content_b": "[{\"id\": 1, \"name\": \"C\"}]",
      "expected_diff": "^ {\"setkeys\":[\"id\"]}\n@ [{\"id\":1},\"name\"]\n- \"A\"\n+ \"C\"\n@ [1]\n- {\"id\":1,\"name\":\"B\"}\n",
      "args": [
        "-setkeys=id"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "^ {\"setkeys\":[\"id\"]}\n@ [{\"id\":1},\"name\"]\n- \"B\"\n+ \"C\"\n",
    "error": "output mismatch:\nExpected:\n^ {\"setkeys\":[\"id\"]}\n@ [{\"id\":1},\"name\"]\n- \"A\"\n+ \"C\"\n@ [1]\n- {\"id\":1,\"name\":\"B\"}\n\nActual:\n^ {\"setkeys\":[\"id\"]}\n@ [{\"id\":1},\"name\"]\n- \"B\"\n+ \"C\"\n",
    "duration": "6.133208ms"
  },
  {
    "test_case": {
      "name": "set_with_null_values",
      "description": "Set operations with null values",
      "category": "edge_cases",
      "content_a": "[null, 1, null, 2]",
      "content_b": "[1, null, 3]",
      "expected_diff": "^ \"SET\"\n@ [{}]\n- 2\n+ 3\n",
      "args": [
        "-set"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "^ \"SET\"\n@ [{}]\n- 2\n+ 3\n",
    "duration": "5.128916ms"
  },
  {
    "test_case": {
      "name": "multiset_duplicate_counting",
      "description": "Multiset properly counts duplicates",
      "category": "edge_cases",
      "content_a": "[1, 1, 1, 2, 2]",
      "content_b": "[1, 1, 2, 2, 2, 3]",
      "expected_diff": "^ \"MULTISET\"\n@ [[]]\n- 1\n+ 2\n+ 3\n",
      "args": [
        "-mset"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "^ \"MULTISET\"\n@ [[]]\n- 1\n+ 3\n+ 2\n",
    "error": "output mismatch:\nExpected:\n^ \"MULTISET\"\n@ [[]]\n- 1\n+ 2\n+ 3\n\nActual:\n^ \"MULTISET\"\n@ [[]]\n- 1\n+ 3\n+ 2\n",
    "duration": "6.83695ms"
  },
  {
    "test_case": {
      "name": "precision_edge_boundary",
      "description": "Precision exactly at boundary",
      "category": "edge_cases",
      "content_a": "{\"val\": 1.0}",
      "content_b": "{\"val\": 1.1}",
      "args": [
        "-precision=0.1"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "^ {\"precision\":0.1}\n@ [\"val\"]\n- 1\n+ 1.1\n",
    "error": "exit code mismatch: expected 0, got 1",
    "duration": "6.58953ms"
  },
  {
    "test_case": {
      "name": "precision_just_over_boundary",
      "description": "Precision just over boundary",
      "category": "edge_cases",
      "content_a": "{\"val\": 1.0}",
      "content_b": "{\"val\": 1.10001}",
      "expected_diff": "^ {\"precision\":0.1}\n@ [\"val\"]\n- 1\n+ 1.10001\n",
      "args": [
        "-precision=0.1"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "^ {\"precision\":0.1}\n@ [\"val\"]\n- 1\n+ 1.10001\n",
    "duration": "5.559606ms"
  },
  {
    "test_case": {
      "name": "very_long_string",
      "description": "Very long string values",
      "category": "edge_cases",
      "content_a": "{\"long\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"}",
      "content_b": "{\"long\": \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"}",
      "expected_diff": "@ [\"long\"]\n- \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+ \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"long\"]\n- \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+ \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"\n",
    "duration": "18.567752ms"
  },
  {
    "test_case": {
      "name": "object_key_with_quotes",
      "description": "Object keys containing quote characters",
      "category": "edge_cases",
      "content_a": "{\"key\\\"with\\\"quotes\": 1}",
      "content_b": "{\"key\\\"with\\\"quotes\": 2}",
      "expected_diff": "@ [\"key\\\"with\\\"quotes\"]\n- 1\n+ 2\n",
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "core"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"key\\\"with\\\"quotes\"]\n- 1\n+ 2\n",
    "duration": "6.797051ms"
  },
  {
    "test_case": {
      "name": "invalid_json_input",
      "description": "Malformed JSON input should cause error",
      "category": "errors",
      "content_a": "{\"invalid\": json}",
      "content_b": "{}",
      "expected_exit": 65,
      "should_error": true,
      "compliance_level": "core"
    },
    "passed": false,
    "actual_exit": 2,
    "error": "exit code mismatch: expected 65, got 2",
    "duration": "6.423049ms"
  },
  {
    "test_case": {
      "name": "invalid_json_second_input",
      "description": "Malformed JSON in second input",
      "category": "errors",
      "content_a": "{}",
      "content_b": "{\"invalid\": syntax",
      "expected_exit": 65,
      "should_error": true,
      "compliance_level": "core"
    },
    "passed": false,
    "actual_exit": 2,
    "error": "exit code mismatch: expected 65, got 2",
    "duration": "5.211773ms"
  },
  {
    "test_case": {
      "name": "precision_with_set_conflict",
      "description": "Precision option conflicts with set option",
      "category": "errors",
      "content_a": "[1,2,3]",
      "content_b": "[1,2,4]",
      "args": [
        "-set",
        "-precision=0.1"
      ],
      "expected_exit": 2,
      "should_error": true,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 2,
    "duration": "5.601841ms"
  },
  {
    "test_case": {
      "name": "precision_with_multiset_conflict",
      "description": "Precision option conflicts with multiset option",
      "category": "errors",
      "content_a": "[1,2,3]",
      "content_b": "[1,2,4]",
      "args": [
        "-mset",
        "-precision=0.1"
      ],
      "expected_exit": 2,
      "should_error": true,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 2,
    "duration": "8.644283ms"
  },
  {
    "test_case": {
      "name": "invalid_setkeys_empty",
      "description": "Empty setkey should cause error",
      "category": "errors",
      "content_a": "[{\"id\":1}]",
      "content_b": "[{\"id\":2}]",
      "args": [
        "-setkeys="
      ],
      "expected_exit": 2,
      "should_error": true,
      "compliance_level": "extended"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "@ [0,\"id\"]\n- 1\n+ 2\n",
    "error": "exit code mismatch: expected 2, got 1",
    "duration": "7.89792ms"
  },
  {
    "test_case": {
      "name": "invalid_setkeys_whitespace",
      "description": "Whitespace-only setkey should cause error",
      "category": "errors",
      "content_a": "[{\"id\":1}]",
      "content_b": "[{\"id\":2}]",
      "args": [
        "-setkeys= , "
      ],
      "expected_exit": 2,
      "should_error": true,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 2,
    "duration": "5.467429ms"
  },
  {
    "test_case": {
      "name": "invalid_opts_json",
      "description": "Malformed JSON in -opts parameter",
      "category": "errors",
      "content_a": "{}",
      "content_b": "{}",
      "args": [
        "-opts={invalid json}"
      ],
      "expected_exit": 2,
      "should_error": true,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 2,
    "duration": "4.718156ms"
  },
  {
    "test_case": {
      "name": "patch_and_translate_conflict",
      "description": "Cannot use patch and translate modes together",
      "category": "errors",
      "content_a": "{}",
      "content_b": "{}",
      "args": [
        "-p",
        "-t=jd2patch"
      ],
      "expected_exit": 64,
      "should_error": true,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "error": "exit code mismatch: expected 64, got 2",
    "duration": "11.757872ms"
  },
  {
    "test_case": {
      "name": "invalid_translation_format",
      "description": "Invalid format specification for translation",
      "category": "errors",
      "content_a": "{}",
      "args": [
        "-t=invalid2format"
      ],
      "expected_exit": 64,
      "should_error": true,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 64, got 2",
    "duration": "5.194916ms"
  },
  {
    "test_case": {
      "name": "invalid_diff_format",
      "description": "Invalid diff format specification",
      "category": "errors",
      "content_a": "{}",
      "content_b": "{}",
      "args": [
        "-f=invalid"
      ],
      "expected_exit": 64,
      "should_error": true,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "error": "exit code mismatch: expected 64, got 2",
    "duration": "5.342346ms"
  },
  {
    "test_case": {
      "name": "too_many_arguments_diff",
      "description": "Too many arguments in diff mode",
      "category": "errors",
      "content_a": "{}",
      "args": [
        "file1.json",
        "file2.json",
        "file3.json"
      ],
      "expected_exit": 64,
      "should_error": true,
      "compliance_level": "core"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 64, got 2",
    "duration": "4.437893ms"
  },
  {
    "test_case": {
      "name": "too_many_arguments_translate",
      "description": "Too many arguments in translate mode",
      "category": "errors",
      "content_a": "{}",
      "args": [
        "-t=json2yaml",
        "file1.json",
        "file2.json"
      ],
      "expected_exit": 64,
      "should_error": true,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 64, got 2",
    "duration": "5.169165ms"
  },
  {
    "test_case": {
      "name": "nonexistent_file",
      "description": "Error when input file does not exist",
      "category": "errors",
      "args": [
        "/nonexistent/file.json"
      ],
      "expected_exit": 66,
      "should_error": true,
      "compliance_level": "core"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 66, got 2",
    "duration": "5.087493ms"
  },
  {
    "test_case": {
      "name": "malformed_diff_syntax",
      "description": "Malformed diff format in patch mode",
      "category": "errors",
      "content_a": "@ [invalid path syntax\n+ value\n",
      "content_b": "{}",
      "args": [
        "-p"
      ],
      "expected_exit": 65,
      "should_error": true,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "error": "exit code mismatch: expected 65, got 2",
    "duration": "4.523683ms"
  },
  {
    "test_case": {
      "name": "invalid_path_element",
      "description": "Invalid path element in diff",
      "category": "errors",
      "content_a": "@ [123invalid]\n+ value\n",
      "content_b": "{}",
      "args": [
        "-p"
      ],
      "expected_exit": 65,
      "should_error": true,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "error": "exit code mismatch: expected 65, got 2",
    "duration": "4.607621ms"
  },
  {
    "test_case": {
      "name": "patch_context_mismatch",
      "description": "Context mismatch during patch application",
      "category": "errors",
      "content_a": "@ [0]\n[\n  \"expected\"\n- \"remove\"\n+ \"add\"\n]\n",
      "content_b": "[\"actual\",\"remove\"]",
      "args": [
        "-p"
      ],
      "expected_exit": 2,
      "should_error": true,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 2,
    "duration": "5.633803ms"
  },
  {
    "test_case": {
      "name": "invalid_yaml_input",
      "description": "Malformed YAML input",
      "category": "errors",
      "content_a": "key: value\n  invalid: indentation\n",
      "content_b": "key: value",
      "args": [
        "-yaml"
      ],
      "expected_exit": 65,
      "should_error": true,
      "compliance_level": "extended"
    },
    "passed": false,
    "actual_exit": 2,
    "error": "exit code mismatch: expected 65, got 2",
    "duration": "5.750029ms"
  },
  {
    "test_case": {
      "name": "negative_precision",
      "description": "Negative precision value should cause error",
      "category": "errors",
      "content_a": "1.0",
      "content_b": "1.1",
      "args": [
        "-precision=-0.1"
      ],
      "expected_exit": 2,
      "should_error": true,
      "compliance_level": "extended"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "^ {\"precision\":-0.1}\n@ []\n- 1\n+ 1.1\n",
    "error": "exit code mismatch: expected 2, got 1",
    "duration": "6.053368ms"
  },
  {
    "test_case": {
      "name": "invalid_port_number",
      "description": "Invalid port number for web UI",
      "category": "errors",
      "args": [
        "-port=invalid"
      ],
      "expected_exit": 2,
      "should_error": true,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 2,
    "duration": "8.27211ms"
  },
  {
    "test_case": {
      "name": "set_option_basic",
      "description": "Array treated as set ignoring order",
      "category": "options",
      "content_a": "{\"tags\":[1,2,3]}",
      "content_b": "{\"tags\":[3,1,2]}",
      "args": [
        "-set"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "8.87511ms"
  },
  {
    "test_case": {
      "name": "set_option_with_changes",
      "description": "Set operations show additions and removals",
      "category": "options",
      "content_a": "{\"tags\":[\"red\",\"blue\",\"green\"]}",
      "content_b": "{\"tags\":[\"red\",\"blue\",\"yellow\"]}",
      "expected_diff": "^ \"SET\"\n@ [\"tags\",{}]\n- \"green\"\n+ \"yellow\"\n",
      "args": [
        "-set"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "^ \"SET\"\n@ [\"tags\",{}]\n- \"green\"\n+ \"yellow\"\n",
    "duration": "5.144426ms"
  },
  {
    "test_case": {
      "name": "multiset_option",
      "description": "Array treated as multiset counting duplicates",
      "category": "options",
      "content_a": "{\"items\":[1,1,2,3]}",
      "content_b": "{\"items\":[1,2,2,4]}",
      "expected_diff": "^ \"MULTISET\"\n@ [\"items\",[]]\n- 1\n- 3\n+ 2\n+ 4\n",
      "args": [
        "-mset"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "^ \"MULTISET\"\n@ [\"items\",[]]\n- 3\n- 1\n+ 4\n+ 2\n",
    "error": "output mismatch:\nExpected:\n^ \"MULTISET\"\n@ [\"items\",[]]\n- 1\n- 3\n+ 2\n+ 4\n\nActual:\n^ \"MULTISET\"\n@ [\"items\",[]]\n- 3\n- 1\n+ 4\n+ 2\n",
    "duration": "4.464646ms"
  },
  {
    "test_case": {
      "name": "precision_option",
      "description": "Numeric precision tolerance",
      "category": "options",
      "content_a": "{\"value\":10.1}",
      "content_b": "{\"value\":10.15}",
      "args": [
        "-precision=0.1"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "4.96387ms"
  },
  {
    "test_case": {
      "name": "precision_option_exceeded",
      "description": "Precision tolerance exceeded shows difference",
      "category": "options",
      "content_a": "{\"value\":10.0}",
      "content_b": "{\"value\":10.2}",
      "expected_diff": "^ {\"precision\":0.1}\n@ [\"value\"]\n- 10\n+ 10.2\n",
      "args": [
        "-precision=0.1"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "^ {\"precision\":0.1}\n@ [\"value\"]\n- 10\n+ 10.2\n",
    "duration": "8.958224ms"
  },
  {
    "test_case": {
      "name": "setkeys_option",
      "description": "Object matching by specified keys",
      "category": "options",
      "content_a": "{\"users\":[{\"id\":1,\"name\":\"Alice\",\"age\":25}]}",
      "content_b": "{\"users\":[{\"id\":1,\"name\":\"Alice\",\"age\":26}]}",
      "expected_diff": "^ {\"setkeys\":[\"id\"]}\n@ [\"users\",{\"id\":1},\"age\"]\n- 25\n+ 26\n",
      "args": [
        "-setkeys=id"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "^ {\"setkeys\":[\"id\"]}\n@ [\"users\",{\"id\":1},\"age\"]\n- 25\n+ 26\n",
    "duration": "7.442445ms"
  },
  {
    "test_case": {
      "name": "multiple_setkeys",
      "description": "Object matching by multiple keys",
      "category": "options",
      "content_a": "{\"items\":[{\"type\":\"fruit\",\"id\":\"apple\",\"color\":\"red\"}]}",
      "content_b": "{\"items\":[{\"type\":\"fruit\",\"id\":\"apple\",\"color\":\"green\"}]}",
      "expected_diff": "^ {\"setkeys\":[\"type\",\"id\"]}\n@ [\"items\",{\"id\":\"apple\",\"type\":\"fruit\"},\"color\"]\n- \"red\"\n+ \"green\"\n",
      "args": [
        "-setkeys=type,id"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "^ {\"setkeys\":[\"type\",\"id\"]}\n@ [\"items\",{\"id\":\"apple\",\"type\":\"fruit\"},\"color\"]\n- \"red\"\n+ \"green\"\n",
    "duration": "11.267423ms"
  },
  {
    "test_case": {
      "name": "color_option",
      "description": "Color output adds color option header",
      "category": "options",
      "content_a": "{\"a\":1}",
      "content_b": "{\"a\":2}",
      "expected_diff": "^ \"COLOR\"\n@ [\"a\"]\n- 1\n+ 2\n",
      "args": [
        "-color"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "^ \"COLOR\"\n@ [\"a\"]\n\u001b[31m- 1\n\u001b[0m\u001b[32m+ 2\n\u001b[0m",
    "error": "output mismatch:\nExpected:\n^ \"COLOR\"\n@ [\"a\"]\n- 1\n+ 2\n\nActual:\n^ \"COLOR\"\n@ [\"a\"]\n\u001b[31m- 1\n\u001b[0m\u001b[32m+ 2\n\u001b[0m",
    "duration": "6.002049ms"
  },
  {
    "test_case": {
      "name": "yaml_mode",
      "description": "YAML input and output mode",
      "category": "options",
      "content_a": "name: Alice\nage: 25",
      "content_b": "name: Alice\nage: 26",
      "expected_diff": "@ [\"age\"]\n- 25\n+ 26\n",
      "args": [
        "-yaml"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "@ [\"age\"]\n- 25\n+ 26\n",
    "duration": "8.007201ms"
  },
  {
    "test_case": {
      "name": "opts_json_set",
      "description": "JSON options array with SET",
      "category": "options",
      "content_a": "{\"items\":[1,2,3]}",
      "content_b": "{\"items\":[3,1,2]}",
      "args": [
        "-opts=[\"SET\"]"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "5.513612ms"
  },
  {
    "test_case": {
      "name": "opts_precision",
      "description": "JSON options with precision object",
      "category": "options",
      "content_a": "{\"temp\":20.1}",
      "content_b": "{\"temp\":20.15}",
      "args": [
        "-opts=[{\"precision\":0.1}]"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "5.656968ms"
  },
  {
    "test_case": {
      "name": "path_options_set",
      "description": "PathOptions targeting specific path with SET",
      "category": "path_options",
      "content_a": "{\"tags\":[\"a\",\"b\"],\"items\":[1,2]}",
      "content_b": "{\"tags\":[\"b\",\"a\"],\"items\":[2,1]}",
      "expected_diff": "^ {\"@\":[\"tags\"],\"^\":[\"SET\"]}\n@ [\"items\",0]\n[\n- 1\n- 2\n+ 2\n+ 1\n]\n",
      "args": [
        "-opts=[{\"@\":[\"tags\"],\"^\":[\"SET\"]}]"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "^ {\"@\":[\"tags\"],\"^\":[\"SET\"]}\n@ [\"items\",0]\n[\n+ 2\n  1\n@ [\"items\",2]\n  1\n- 2\n]\n",
    "error": "output mismatch:\nExpected:\n^ {\"@\":[\"tags\"],\"^\":[\"SET\"]}\n@ [\"items\",0]\n[\n- 1\n- 2\n+ 2\n+ 1\n]\n\nActual:\n^ {\"@\":[\"tags\"],\"^\":[\"SET\"]}\n@ [\"items\",0]\n[\n+ 2\n  1\n@ [\"items\",2]\n  1\n- 2\n]\n",
    "duration": "5.827874ms"
  },
  {
    "test_case": {
      "name": "path_options_precision",
      "description": "PathOptions with precision on specific field",
      "category": "path_options",
      "content_a": "{\"temp\":20.12,\"pressure\":1013.25}",
      "content_b": "{\"temp\":20.15,\"pressure\":1013.30}",
      "expected_diff": "^ {\"@\":[\"temp\"],\"^\":[{\"precision\":0.1}]}\n@ [\"pressure\"]\n- 1013.25\n+ 1013.3\n",
      "args": [
        "-opts=[{\"@\":[\"temp\"],\"^\":[{\"precision\":0.1}]}]"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "^ {\"@\":[\"temp\"],\"^\":[{\"precision\":0.1}]}\n@ [\"pressure\"]\n- 1013.25\n+ 1013.3\n",
    "duration": "12.729805ms"
  },
  {
    "test_case": {
      "name": "path_options_nested",
      "description": "PathOptions on nested paths",
      "category": "path_options",
      "content_a": "{\"data\":{\"values\":[3,1,2]}}",
      "content_b": "{\"data\":{\"values\":[1,2,3]}}",
      "args": [
        "-opts=[{\"@\":[\"data\",\"values\"],\"^\":[\"SET\"]}]"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "5.290895ms"
  },
  {
    "test_case": {
      "name": "multiple_path_options",
      "description": "Multiple PathOptions in single command",
      "category": "path_options",
      "content_a": "{\"tags\":[\"x\",\"y\"],\"scores\":[85.1,92.05]}",
      "content_b": "{\"tags\":[\"y\",\"x\"],\"scores\":[85.15,92.1]}",
      "args": [
        "-opts=[{\"@\":[\"tags\"],\"^\":[\"SET\"]},{\"@\":[\"scores\"],\"^\":[{\"precision\":0.1}]}]"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "4.497621ms"
  },
  {
    "test_case": {
      "name": "diff_off_option",
      "description": "DIFF_OFF ignores changes at specified path",
      "category": "path_options",
      "content_a": "{\"data\":\"important\",\"timestamp\":\"2023-01-01\"}",
      "content_b": "{\"data\":\"important\",\"timestamp\":\"2023-01-02\"}",
      "args": [
        "-opts=[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 0,
    "duration": "4.541778ms"
  },
  {
    "test_case": {
      "name": "diff_on_allowlist",
      "description": "Allow-list approach with DIFF_OFF root and DIFF_ON specific",
      "category": "path_options",
      "content_a": "{\"important\":\"data\",\"ignore1\":\"x\",\"ignore2\":\"y\"}",
      "content_b": "{\"important\":\"changed\",\"ignore1\":\"z\",\"ignore2\":\"w\"}",
      "expected_diff": "^ {\"@\":[],\"^\":[\"DIFF_OFF\"]}\n^ {\"@\":[\"important\"],\"^\":[\"DIFF_ON\"]}\n@ [\"important\"]\n- \"data\"\n+ \"changed\"\n",
      "args": [
        "-opts=[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"important\"],\"^\":[\"DIFF_ON\"]}]"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "extended"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "^ {\"@\":[],\"^\":[\"DIFF_OFF\"]}\n^ {\"@\":[\"important\"],\"^\":[\"DIFF_ON\"]}\n@ [\"important\"]\n- \"data\"\n+ \"changed\"\n",
    "duration": "8.362554ms"
  },
  {
    "test_case": {
      "name": "patch_format_output",
      "description": "Generate RFC 6902 JSON Patch format",
      "category": "format",
      "content_a": "{\"foo\":\"bar\"}",
      "content_b": "{\"foo\":\"baz\"}",
      "expected_diff": "[{\"op\":\"test\",\"path\":\"/foo\",\"value\":\"bar\"},{\"op\":\"remove\",\"path\":\"/foo\",\"value\":\"bar\"},{\"op\":\"add\",\"path\":\"/foo\",\"value\":\"baz\"}]\n",
      "args": [
        "-f=patch"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "[{\"op\":\"test\",\"path\":\"/foo\",\"value\":\"bar\"},{\"op\":\"remove\",\"path\":\"/foo\",\"value\":\"bar\"},{\"op\":\"add\",\"path\":\"/foo\",\"value\":\"baz\"}]",
    "duration": "6.213687ms"
  },
  {
    "test_case": {
      "name": "patch_format_addition",
      "description": "JSON Patch format for addition",
      "category": "format",
      "content_a": "{}",
      "content_b": "{\"new\":\"value\"}",
      "expected_diff": "[{\"op\":\"add\",\"path\":\"/new\",\"value\":\"value\"}]\n",
      "args": [
        "-f=patch"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "[{\"op\":\"add\",\"path\":\"/new\",\"value\":\"value\"}]",
    "duration": "11.182906ms"
  },
  {
    "test_case": {
      "name": "patch_format_removal",
      "description": "JSON Patch format for removal",
      "category": "format",
      "content_a": "{\"old\":\"value\"}",
      "content_b": "{}",
      "expected_diff": "[{\"op\":\"test\",\"path\":\"/old\",\"value\":\"value\"},{\"op\":\"remove\",\"path\":\"/old\",\"value\":\"value\"}]\n",
      "args": [
        "-f=patch"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "[{\"op\":\"test\",\"path\":\"/old\",\"value\":\"value\"},{\"op\":\"remove\",\"path\":\"/old\",\"value\":\"value\"}]",
    "duration": "5.792497ms"
  },
  {
    "test_case": {
      "name": "patch_format_array",
      "description": "JSON Patch format for array operations",
      "category": "format",
      "content_a": "[1,2]",
      "content_b": "[1,3]",
      "expected_diff": "[{\"op\":\"test\",\"path\":\"/1\",\"value\":2},{\"op\":\"remove\",\"path\":\"/1\",\"value\":2},{\"op\":\"add\",\"path\":\"/1\",\"value\":3}]\n",
      "args": [
        "-f=patch"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 1,
    "actual_diff": "[{\"op\":\"test\",\"path\":\"/0\",\"value\":1},{\"op\":\"test\",\"path\":\"/1\",\"value\":2},{\"op\":\"remove\",\"path\":\"/1\",\"value\":2},{\"op\":\"add\",\"path\":\"/1\",\"value\":3}]",
    "error": "output mismatch:\nExpected:\n[{\"op\":\"test\",\"path\":\"/1\",\"value\":2},{\"op\":\"remove\",\"path\":\"/1\",\"value\":2},{\"op\":\"add\",\"path\":\"/1\",\"value\":3}]\n\nActual:\n[{\"op\":\"test\",\"path\":\"/0\",\"value\":1},{\"op\":\"test\",\"path\":\"/1\",\"value\":2},{\"op\":\"remove\",\"path\":\"/1\",\"value\":2},{\"op\":\"add\",\"path\":\"/1\",\"value\":3}]",
    "duration": "7.436186ms"
  },
  {
    "test_case": {
      "name": "merge_format_output",
      "description": "Generate RFC 7386 JSON Merge Patch format",
      "category": "format",
      "content_a": "{\"a\":\"b\"}",
      "content_b": "{\"a\":\"c\"}",
      "expected_diff": "{\"a\":\"c\"}\n",
      "args": [
        "-f=merge"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "{\"a\":\"c\"}",
    "duration": "5.23572ms"
  },
  {
    "test_case": {
      "name": "merge_format_addition",
      "description": "JSON Merge Patch format for addition",
      "category": "format",
      "content_a": "{\"existing\":1}",
      "content_b": "{\"existing\":1,\"new\":2}",
      "expected_diff": "{\"new\":2}\n",
      "args": [
        "-f=merge"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "{\"new\":2}",
    "duration": "5.189634ms"
  },
  {
    "test_case": {
      "name": "merge_format_removal",
      "description": "JSON Merge Patch format for removal (null)",
      "category": "format",
      "content_a": "{\"keep\":1,\"remove\":2}",
      "content_b": "{\"keep\":1}",
      "expected_diff": "{\"remove\":null}\n",
      "args": [
        "-f=merge"
      ],
      "expected_exit": 1,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 1,
    "actual_diff": "{\"remove\":null}",
    "duration": "8.919703ms"
  },
  {
    "test_case": {
      "name": "translate_jd_to_patch",
      "description": "Translate jd format to JSON Patch",
      "category": "translation",
      "content_a": "@ [\"foo\"]\n- \"bar\"\n+ \"baz\"\n",
      "expected_diff": "[{\"op\":\"test\",\"path\":\"/foo\",\"value\":\"bar\"},{\"op\":\"remove\",\"path\":\"/foo\",\"value\":\"bar\"},{\"op\":\"add\",\"path\":\"/foo\",\"value\":\"baz\"}]\n",
      "args": [
        "-t=jd2patch"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 0, got 2",
    "duration": "9.503631ms"
  },
  {
    "test_case": {
      "name": "translate_patch_to_jd",
      "description": "Translate JSON Patch to jd format",
      "category": "translation",
      "content_a": "[{\"op\":\"add\",\"path\":\"/foo\",\"value\":\"bar\"}]\n",
      "expected_diff": "@ [\"foo\"]\n+ \"bar\"\n",
      "args": [
        "-t=patch2jd"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 0, got 2",
    "duration": "4.348048ms"
  },
  {
    "test_case": {
      "name": "translate_jd_to_merge",
      "description": "Translate jd format to JSON Merge Patch",
      "category": "translation",
      "content_a": "@ [\"a\"]\n+ \"b\"\n",
      "expected_diff": "{\"a\":\"b\"}\n",
      "args": [
        "-t=jd2merge"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 0, got 2",
    "duration": "4.691885ms"
  },
  {
    "test_case": {
      "name": "translate_merge_to_jd",
      "description": "Translate JSON Merge Patch to jd format",
      "category": "translation",
      "content_a": "{\"foo\":\"bar\"}\n",
      "expected_diff": "^ \"MERGE\"\n@ [\"foo\"]\n+ \"bar\"\n",
      "args": [
        "-t=merge2jd"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 0, got 2",
    "duration": "4.785675ms"
  },
  {
    "test_case": {
      "name": "translate_json_to_yaml",
      "description": "Translate JSON to YAML format",
      "category": "translation",
      "content_a": "{\"name\":\"Alice\",\"age\":30}\n",
      "expected_diff": "age: 30\nname: Alice\n",
      "args": [
        "-t=json2yaml"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 0, got 2",
    "duration": "8.261455ms"
  },
  {
    "test_case": {
      "name": "translate_yaml_to_json",
      "description": "Translate YAML to JSON format",
      "category": "translation",
      "content_a": "name: Alice\nage: 30\n",
      "expected_diff": "{\"age\":30,\"name\":\"Alice\"}\n",
      "args": [
        "-t=yaml2json"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": false,
    "actual_exit": 2,
    "actual_diff": "\nUsage: jd [OPTION]... FILE1 [FILE2]\nDiff and patch JSON files.\n\nPrints the diff of FILE1 and FILE2 to STDOUT.\nWhen FILE2 is omitted the second input is read from STDIN.\nWhen patching (-p) FILE1 is a diff.\n\nOptions Header: When options are provided, they are displayed at the\nbeginning of the diff output to show how the diff was produced:\n  ^ \"SET\"                     (arrays treated as sets)\n  ^ {\"precision\":0.001}       (number comparison precision)\n  ^ {\"setkeys\":[\"id\"]}        (object matching keys)\nThis helps understand diff behavior and enables reproducible results.\n\nOptions:\n  -color       Print color diff.\n  -p           Apply patch FILE1 to FILE2 or STDIN.\n  -o=FILE3     Write to FILE3 instead of STDOUT.\n  -opts='[]'   JSON array of options. Supports global options and PathOptions.\n               Global: [\"SET\"], [\"MULTISET\"], [{\"precision\":0.1}], [{\"setkeys\":[\"id\"]}], [\"DIFF_ON\"], [\"DIFF_OFF\"]\n               PathOptions target specific paths: [{\"@\":[\"path\"],\"^\":[\"SET\"]}]\n               Example: [{\"@\":[\"users\"],\"^\":[\"SET\"]},{\"@\":[\"scores\",0],\"^\":[{\"precision\":0.1}]}]\n  -set         Treat arrays as sets. Same as -opts='[\"SET\"]'.\n  -mset        Treat arrays as multisets (bags). Same as -opts='[\"MULTISET\"]'.\n  -setkeys     Keys to identify set objects. Same as -opts='[{\"setkeys\":[\"key1\",\"key2\"]}]'.\n  -yaml        Read and write YAML instead of JSON.\n  -port=N      Serve web UI on port N\n  -precision=N Maximum absolute difference for numbers to be equal.\n               Same as -opts='[{\"precision\":N}]'. Example: -precision=0.00001\n  -f=FORMAT    Read and write diff in FORMAT \"jd\" (default), \"patch\" (RFC 6902) or\n               \"merge\" (RFC 7386)\n  -t=FORMATS   Translate FILE1 between FORMATS. Supported formats are \"jd\",\n               \"patch\" (RFC 6902), \"merge\" (RFC 7386), \"json\" and \"yaml\".\n               FORMATS are provided as a pair separated by \"2\". E.g.\n               \"yaml2json\" or \"jd2patch\".\n\nExamples:\n  jd a.json b.json\n  cat b.json | jd a.json\n  jd -o patch a.json b.json; jd patch a.json\n  jd -set a.json b.json\n  jd -f patch a.json b.json\n  jd -f merge a.json b.json\n  jd -opts='[{\"@\":[\"items\"],\"^\":[\"SET\"]}]' a.json b.json\n  jd -opts='[{\"@\":[\"temperature\"],\"^\":[{\"precision\":0.1}]}]' a.json b.json\n  jd -opts='[{\"@\":[\"timestamp\"],\"^\":[\"DIFF_OFF\"]}]' a.json b.json\n  jd -opts='[{\"@\":[],\"^\":[\"DIFF_OFF\"]},{\"@\":[\"userdata\"],\"^\":[\"DIFF_ON\"]}]' a.json b.json\n\nVersion: HEAD\n\n",
    "error": "exit code mismatch: expected 0, got 2",
    "duration": "5.591353ms"
  },
  {
    "test_case": {
      "name": "patch_mode_application",
      "description": "Apply patch to document using -p flag",
      "category": "patching",
      "content_a": "@ [\"value\"]\n+ 42\n",
      "content_b": "{}",
      "expected_diff": "{\"value\":42}\n",
      "args": [
        "-p"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 0,
    "actual_diff": "{\"value\":42}",
    "duration": "5.706449ms"
  },
  {
    "test_case": {
      "name": "patch_mode_array_context",
      "description": "Apply array patch with context validation",
      "category": "patching",
      "content_a": "@ [1]\n[\n  \"a\"\n- \"b\"\n+ \"x\"\n  \"c\"\n]\n",
      "content_b": "[\"a\",\"b\",\"c\"]",
      "expected_diff": "[\"a\",\"x\",\"c\"]\n",
      "args": [
        "-p"
      ],
      "expected_exit": 0,
      "should_error": false,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 0,
    "actual_diff": "[\"a\",\"x\",\"c\"]",
    "duration": "6.66735ms"
  },
  {
    "test_case": {
      "name": "patch_mode_context_error",
      "description": "Patch application fails with context mismatch",
      "category": "patching",
      "content_a": "@ [0]\n[\n  \"wrong\"\n- \"b\"\n+ \"x\"\n]\n",
      "content_b": "[\"a\",\"b\",\"c\"]",
      "args": [
        "-p"
      ],
      "expected_exit": 2,
      "should_error": true,
      "compliance_level": "format"
    },
    "passed": true,
    "actual_exit": 2,
    "duration": "5.036413ms"
  }
]